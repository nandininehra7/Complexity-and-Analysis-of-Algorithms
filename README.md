## Name - Nandini Nehra
## Roll No - UE225058

# üöÄ Analysis & Design of Algorithm üìä

Welcome to the repository showcasing various algorithms and their time complexity analysis! Dive into the world of efficient coding and algorithmic mastery.

## Practical -01: Selection Sort Analysis
This practical implements the selection sort algorithm, a simple yet effective way to sort arrays. It has a time complexity of O(n^2), where 'n' is the number of elements in the array.

![Selection Sort](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/7140ad5e-576b-43af-81b2-8cc170204185)

## Practical -02: Sum of n Numbers
This practical sums up the elements in an array, showcasing straightforward computation with a time complexity of O(n).

![Sum of Numbers](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/a825b9d9-46ce-4fe9-a09d-18d6bcab62c8)

## Practical -03: Towers of Hanoi üè∞
The Tower of Hanoi algorithm demonstrates the beauty of recursive solutions. With a time complexity of O(2^n), it's a classic problem to master.

![Towers of Hanoi](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/e7b5895f-a6b2-4e8c-9088-fe466c5daeba)

## Practical -04: Permutation Generator
Generate permutations like a pro! This practical employs recursive backtracking with a time complexity of O(n!).

![Permutation Generator](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/ca418eeb-e910-4206-9076-0f0e575feba1)

## Practical -05: Power Function ‚ö°Ô∏è
1. Brute approach: O(2^n)
2. Optimal approach: O(log n)

Harness the power of exponentiation with these efficient algorithms.

## Practical -06: Merge Sort üîÑ
Sort like a boss with Merge Sort! Its time complexity of O(n log n) makes it a go-to for sorting large arrays.

![Merge Sort](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/f481521a-fbd6-48a6-b5cd-74f4a341471f)

## Practical -07: Quick Sort üö™
Quick Sort partitions arrays swiftly, boasting an average time complexity of O(n log n) and a worst-case of O(n^2).

![Quick Sort](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/1b47b02c-1939-436a-97fa-38fa12f5fa62)

## Practical -08: Merging of Two Sorted Lists
Merge sorted lists seamlessly with a time complexity of O(n).

![Merge Sorted Lists](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/caae64a0-2a0b-4be5-93a7-37aa6edc604f)

## Practical -09: Binary Search üîç
Search with speed using Binary Search! Its time complexity of O(log n) makes it ideal for large sorted arrays.

![Binary Search](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/26ad95e2-e88c-4c19-8c09-39e67712d3fb)

## Practical -10: Iterative Quick Sort
An iterative take on Quick Sort, maintaining its efficiency with a time complexity of O(n log n).

## Practical -11: Correct Position
Find the correct position with ease, optimized with a time complexity of O(n).

![Correct Position](https://github.com/Abhibhav2003/AlgorithmsAndTheirComplexityAnalysis/assets/139039304/479d0765-af5d-4c64-b744-fd76cdebd9bf)

## Practical -12: Cycle Detection üîÑ
Detect cycles in graphs using Union-Find, a crucial tool with various applications in graph theory.

## Practical -13: Dijkstra's üõ£Ô∏è
Discover shortest paths efficiently with Dijkstra's algorithm, perfect for weighted graphs with non-negative weights.

## Practical -14: Prim's üå≥
Build Minimum Spanning Trees with Prim's algorithm, a cornerstone in graph theory and network optimization.

## Practical -15: Multistage Graph
Navigate through multistage graphs and find optimal paths with ease.

## Practical -16: Kruskal's üåê
Construct Minimum Spanning Trees using Kruskal's algorithm, a key player in network design and optimization.
